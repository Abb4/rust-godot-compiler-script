extern crate clap;
use std::{
    path::{Path, PathBuf},
    process::Command,
};

use clap::{crate_version, App, Arg};

fn main() {
    let app = App::new("rust-godot compiler script")
        .about("compiles rust and automatically and binds output into godot by creating necessary gd classes")
        .version(crate_version!())
        .arg(crate_dir_path_arg())
        .arg(crate_target_dir_path_arg());

    let matches = app.get_matches();

    handle_user_input(matches);
}

fn crate_dir_path_arg() -> Arg<'static, 'static> {
    Arg::with_name("crate-dir")
        .required(true)
        .takes_value(true)
        .short("c")
        .long("crate-dir")
        .value_name("PATH")
        .help("Directory where the rust crate is located at")
}

fn crate_target_dir_path_arg() -> Arg<'static, 'static> {
    Arg::with_name("target-dir")
        .required(true)
        .takes_value(true)
        .short("t")
        .long("target-dir")
        .value_name("PATH")
        .help("Directory for all dlls generated by cargo run")
}

fn handle_user_input(matches: clap::ArgMatches) {
    let crate_path = path_from_arg("crate-dir", &matches);
    let target_path = path_from_arg("target-dir", &matches);

    build_crate_at_path_windows(&crate_path);

    move_built_dll_to_target_path(&crate_path, &target_path);

    create_godot_classes_from_crate_source(&crate_path, &target_path);
}

fn create_godot_classes_from_crate_source(crate_path: &PathBuf, target_path: &PathBuf) {
    todo!() // TODO, see #5
}

fn move_built_dll_to_target_path(crate_path: &PathBuf, target_path: &PathBuf) {
    todo!() // TODO, see #3
}

fn build_crate_at_path_windows(crate_path: &PathBuf) {
    // TODO maybe rust offers a better ways to compile a crate
    // TODO need to implement linux version of this and test linux path handling here, see #2
    Command::new("cmd")
        .current_dir(crate_path)
        .args(["/C", "cargo build"])
        .status()
        .expect("cargo build command failed");
}

fn path_from_arg(arg_name: &str, matches: &clap::ArgMatches) -> PathBuf {
    let dir_path = matches
        .value_of(arg_name)
        .expect(format!("Argument with name {} not found", arg_name).as_str());

    Path::new(dir_path).to_path_buf()
}
